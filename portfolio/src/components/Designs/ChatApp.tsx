import React from 'react'

import NavBar from '../NavBar'

import design from '../../assets/images/chat_app.jpg'

import './Designs.scss'

const ChatApp: React.FC = () => (
  <div>
    <NavBar />
    <br/>
    <br/>
    <br />
    <br />
    <br />
    <br />
    <br />
    <div className="designs-container">
      <div className="designs-card">
        <br />
        <h1> CHAT APP </h1>
        <p><h2>I. Understanding the Goals</h2></p>
            <p>
               The goal of this post is to design a chat application that can be used by an online multiplayer game that my friend is building.
            </p>
            <p>
                The users of this app will likely only reside in the United States, since my friend is mainly building the game just to see if he can pull it off. 
            </p>
            <p>
                The chat system have similar inputs to that of the gameâ€” authenticated user GUIDs, user aliases, and session id. Said session id will be generated by the system when the user creates a new chat.
            </p>
            <p>
                Outputs of the system will include the session id (which can be shared with other users to join in the chat session).
            </p>
            <p>
                The more obvious inputs and outputs, I haven't yet mentioned, are, of course, the chat messages themselves.
            </p>
            <br />
        <p><h2>II. Scope</h2></p>
            <p>
                The current design will only support web browser clients, since the game will be a browser only game. However, if this game were to support mobile clients, in the future the only change to the design would be the additions of the appropriate client and <a href="https://samnewman.io/patterns/architectural/bff/">BFF</a> codebases.
            </p>
            <p>
                This design will also include a 3rd party OAuth system for authentication and authorization.
            </p>
            <p>
                Although, analytics, logging and monitoring are out of the scope of this design, I will strongly recommend for my friend both 1) to implement Google Analytics to get frontend metrics and 2) to consider the addition of the ELK stack or Splunk for log management and a tool such as DataDog or AWS CloudWatch for monitoring and metrics. 
            </p>
            <br />
        <p><h2>III. Scale</h2></p>
            <p>
                Like most chat applications, this one will likely be both read and write heavy.
            </p>
            <p>
                At this time, there is no plan to handle DDoS or any attack of that sort, but adding rate limiting would be trivial if it were needed in the future. 
            </p>
            <br />
        <p><h2>IV. Design</h2></p>
            <br />
            <img src={design} />
            <br />
            <p><h3>Frontend</h3></p>
                <p>
                    I've designed for the static assets of the system to be deployed to blob storage. This will be delivered to end users via a CDN distribution.
                </p>
                <p>
                    Additionally, I've decided to abstract UI logic from data fetching by implementing a BFF behind the static assets. The BFF will be in charge of both interacting with the service layer and calling the external OAuth provider. Once a user is authorized, they are sent to a page where they can then initiate a chat session and invite a friend to the session.
                </p>
                <br />
            <p><h3>Load Balancers</h3></p>
                <p>
                    The load balancing layer acts as a reverse proxy for the chat service. To prevent the chat service from being a point of failure at scale, I designed for the service layer to be horizontally scalable. Furthermore, I designed the load balancing layer to implement a <a href="https://en.wikipedia.org/wiki/Consistent_hashing#Basic_Technique" rel="noreferrer noopener" target="blank">consistent hashing strategy</a> with users with the same session id being routed to the same server. Since this helps us avoid the problem of servers being reassigned to users as servers are both added and removed from the cluster, we can add an in-memory cache, such as Memcached, that'll lower the need to go grab message history from the database.
                </p>
                <br />
            <p><h3>More about Chat Service</h3></p>
            <p>
                After a user initiates a new chat on via the browser, chat service opens a bi-directional communication channel for the BFF to communicate with the service. I chose this method instead of polling, because the latter would put considerable load on our server at scale. Additionally by keeping an open connection, we will likely experience lower latencies.
            </p>
            <p>
                Once a friend joins the chat session, chat service will also open a bi-di channel for them. After one user types "hello world!" and clicks send, the message will go through the LB proxy to user's bi-di channel to the server and then through the friend's bi-di channel then through the LB proxy to their client. The chat service servers will also cache the messages (for chat participants coming in later), as will the BFF.
            </p>
            <br />
        <p><h3>Database</h3></p>
            <p>
                The database would be for storing chat logs by session id. Since this isn't overly relational data, NoSQL document-type databases would be useful here. Additionally, since it is good practice to design NoSQL solutions to conform to the application's data access patterns, lookups will be faster too.
            </p>
            <p>
                One problem I wanted to be mindful of should we go with a self-managed database solution to save money is how we'll handle both scaling reads and making our database solution fault-tolerant and highly available. In this regard, having a leader-replica configuration should work here. For a single region deployment, one leader with two replicas in different availability zones is more than sufficient.
            </p>
            <p>
                For managing failover, I think using something like Zookeeper or etcd to manage leader election should be more than sufficient. We could even add in ProxySQL to handle delegating reads and writes, but adding that in the service configs/logic would be a smaller lift.
            </p>
        <br />
        <p><h2>V. Concluding Thoughts</h2></p>
                <p>
                   My friend and I are actually going to build this, so stay tuned... 
                </p>
        <br />
      </div>
    </div>
  </div>
)

export default ChatApp